#!/usr/bin/python3
import serial
from cmd import Cmd
import sys
import bincopy
import math
import os
import signal
import time


class Rcmon(Cmd):

    def __init__(self, devName, baud, redirectUart = False):
        Cmd.__init__(self)
        self.conn(devName, baud)
        self.setProcessorDebugModeStatus(True)
        print("Entering processor debug mode...")
        self.processing = False
        self.redirectUart = redirectUart
        if redirectUart :
            print("Redirection UART to RCMON.")

    def tryConnection(self):
        tryCount = 5
        for i in range(0, tryCount):
            self.ser.write(b"UUUU")
            time.sleep(2)
            res = self.protocolRead("fffffff0", 1)
            if len(res) > 0:
                return
            print("Connection Error. Trynig again.")
        print("Could not connect to UART.");

    def configDDR2(self):
        self.protocolWrite("fff00100", ["16208444", "00c8908c", "13410000", "00000100", "10430105"])

    def configUart(self):
        self.protocolWrite( "80000108", ["00000000"] )
        self.protocolWrite( "80000108", ["00000800"] )
        self.protocolWrite( "80000108", ["00000000"] )
        self.protocolWrite( "8000010c", ["99999999"] )
        self.protocolWrite( "80000108", ["00000003"] )

    def configUartDebugMode(self):
        self.configUart()
        self.protocolWrite("80000108", ["00000843"])

    def readUartDebug(self):
        return self.protocolRead("8080000110", 1)

    def conn(self, devName, baud):
        print("Try to connect to "+ devName +" @ {} baudrate".format(baud))
        self.ser = serial.Serial(devName, baudrate=baud , timeout = 0.1)
        self.tryConnection()
        self.configDDR2()
        print("Connected.")

    def do_conn(self, args):
        """conn device baudrate"""
        args = args.split()
        self.conn(args[0], args[1])

    def do_fix(self, args):
        """Use it to try  fix UART connection."""
        print("Trying to fix connection.")
        self.tryConnection()

    def do_EOF(self, args):
        print("EOF received.")
        self.do_q(args)

    def str2barray(self, s, base):
        bitsPerChar = math.log(base,2)
        bytesPerChar = bitsPerChar / 8
        totalBytes = math.ceil(bytesPerChar * len(s))
        return int(s,base).to_bytes(totalBytes, byteorder="big")

    def do_sw(self,args):
        """sw hexAddress (data32bits)+ """
        args = args.split()
        addr = int(args[0],16)
        data = args[1:]
        if len(data) == 0:
            print("invalid amount of data.")
            return
        amount = len(data)
        if amount > (2**6) or amount < 1:
            print("Amount need to fit in 6 bits")
            return
        mes = "11"+"{:06b}".format(amount-1)+"{:032b}".format(addr)
        print("<  {:010x}".format(int(mes,2)))
        mes = self.str2barray(mes,2)
        self.ser.write(mes)
        for d in data:
            d = int(d,16)
            bd = "{:032b}".format(d)
            print("<  {:08x}".format(d))
            barray = self.str2barray(bd,2)
            self.ser.write(barray)

    def replayserialfile(self, fileName):
        r = open(fileName, "rb").read()
        self.ser.write(r)

    def do_replay(self,args):
        """replay fileName"""
        args = args.split()
        self.replayserialfile(args[0])

    def runHexFile():
        pass

    def do_run(self, args):
        """run addrHex """
        args = args.split()
        addr = int(args[0], 16)
        pc = "{:08x}".format(addr)
        npc = "{:08x}".format(addr+4)
        if self.redirectUart:
            self.configUartDebugMode()
        else:
            self.configUart()
        #set pc and npc
        self.protocolWrite("90400010", [pc, npc])
        #zero registers
        self.protocolWrite("90300204", ["00000000"]*7)
        baseRegAddr = 0x90300000
        for i in range(0, 16):
            iterAddr = baseRegAddr + (i * 0x20)
            iterAddr = "{:08x}".format(iterAddr)
            self.protocolWrite(iterAddr, ["00000000"]*8)
        self.setProcessorDebugModeStatus(False) # begin execution
        #execution loop
        self.processing = True
        while self.processing:
            #check if processor entered debug mode
            if self.isProcessorInDebugMode():
                self.processing = False
            if self.redirectUart: #get uart output
                res = self.protocolRead("80000110",1)
                if len(res) > 0:
                    print(chr(int(res[0],16)), end="", flush=True)
        print("")
        self.setProcessorDebugModeStatus(True)

    def isProcessorInDebugMode(self, pid = 0):
        dsuBreakStepReg = int(self.protocolRead("90000020", 1)[0], 16)
        mask = 1 << pid
        dsuBreakStepReg = dsuBreakStepReg and pid
        dsuBreakStepReg = dsuBreakStepReg >> pid
        if dsuBreakStepReg == 1:
            return True
        else:
            return False


    def setProcessorDebugModeStatus(self, newStatus, pid = 0):
        if newStatus == True:
            self.protocolWrite("90000020", ["0000ffff"])
        else:
            self.protocolWrite("90000020", ["00000000"])


    def do_srecl(self, args):
        """srecl srecFileName addresToLadInHex """
        args = args.split()
        fileName = args[0]
        addr = int(args[1],16)
        f = bincopy.BinFile()
        f.add_srec_file(fileName)
        d = f.as_binary()
        datalen = len(d)
        datatimes = math.ceil( datalen//64 )
        for i in range(0,datatimes):
            sendData = d[i*64:64+(i*64)]
            mes = "11"+"{:06b}".format(len(sendData)-1)+"{:032b}".format(addr)
            mes = self.str2barray(mes,2)
            self.ser.write(mes + sendData)

    def do_sr(self,args):
        """sr hexAddress amount """
        if self.ser == None:
            print("Serial not connected.")
            return
        args = args.split()
        addr = int(args[0],16)
        if addr > 0xffffffff:
            print("Invalid 32bit adress {:x}".format(addr))
            return
        amount = int(args[1])
        if amount > (2**6) or amount < 1:
            print("Amount need to fit in 6 bits")
            return
        mes = "10"+"{:06b}".format(amount-1)+"{:032b}".format(addr)
        print("<  {:010x}".format(int(mes,2)))
        mes = self.str2barray(mes,2)
        self.ser.write(mes)
        for t in range(0,amount):
            res = self.ser.read(4)
            while(len(res) > 0):
                res = int.from_bytes(res, byteorder='big', signed=False)
                print(">  {:08x}".format(res))
                res = self.ser.read(4)

    def do_i(self, args, echo=True):
        """i serialCommandsFileName """
        args = args.split()
        lines = open(args[0], "r").read().split("\n")
        lines = [l.partition("-")[0] for l in lines]
        data = "".join(lines)
        data = data.replace(" ","")
        data = data.replace("\t","")
        data = data.replace("\n","")
        serData = self.str2barray(data, 16);
        if echo:
            print("<  " + data)
        self.ser.write(serData)
        res = self.ser.read(4)
        while(len(res) > 0):
            res = int.from_bytes(res, byteorder='big', signed=False)
            if echo:
                print(">  {:08x}".format(res))
            res = self.ser.read(4)

    def protocolWrite(self, addrHex, dataHexList):
        dataHexList = dataHexList[0:64]
        addr = int(addrHex, 16)
        mes = "11"+"{:06b}".format(len(dataHexList)-1)+"{:032b}".format(addr)
        data = self.str2barray(mes,2)
        for dhex in dataHexList:
            data += self.str2barray(dhex,16)
        self.ser.write(data)

    def protocolRead(self, addrHex, count):
        if count < 1:
            return []
        if count > 64:
            count = 64
        addr = int(addrHex, 16)
        mes = "10"+"{:06b}".format(count-1)+"{:032b}".format(addr)
        self.ser.write(self.str2barray(mes,2))
        data = []
        for i in range(0,count):
            res = self.ser.read(4)
            res = int.from_bytes(res, byteorder='big', signed=False)
            data.append("{:08x}".format(res))
        return data

    def send(self, hexStr):
        self.ser.write(self.str2barray(hexStr,16))

    def recv(self, numBytes):
        res = self.ser.read(4)
        self.processing = True
        while(len(res) < numBytes) and self.processing :
            res += self.ser.read(4)
        return res

    def handle_run_trap(self):
        self.processing = False
        self.send("8090000020") # get trap base register to get trap type
        tt = self.ser.read(4)[3]
        self.send("8090400010") # get pc
        pc = self.ser.read(4)
        pc = int.from_bytes(pc, byteorder='big', signed=False)
        print(
"""Trap occured!
PC = {:08x}
Trap type = {:x}""".format(pc,tt))



    def do_q(self,args):
        print("Quiting...");
        quit()

if __name__ == '__main__':
    if len(sys.argv) < 3:
        print("Usage: rcmon device baudrate")
        quit()
    print("Starting Rcmon...")
    dev = sys.argv[1]
    baud = sys.argv[2]
    redirectUart = True if "-u" in sys.argv else False
    prompt = Rcmon(dev, baud, redirectUart)
    prompt.prompt = 'rcmon> '

    def signal_handler(sig, frame):
        if not prompt.processing:
            print("")
            prompt.do_q("")
        else:
            prompt.processing = False
    signal.signal(signal.SIGINT, signal_handler)

    prompt.cmdloop('')
