#!/usr/bin/python3
import serial
from cmd import Cmd
import sys
import bincopy
import math
import os
import signal


class Rcmon(Cmd):

    def __init__(self, devName, baud):
        Cmd.__init__(self)
        self.conn(devName, baud)
        self.processng = False

    def try_connect():
        pass

    def conn(self, devName, baud):
        print("Try to open "+devName)
        self.ser = serial.Serial(devName, baudrate=baud , timeout = 0.05)
        self.ser.write(b"UUUU")
        print("Connected.")

    def do_conn(self, args):
        """conn device baudrate"""
        args = args.split()
        self.conn(args[0], args[1])

    def str2barray(self, s, base):
        bitsPerChar = math.log(base,2)
        bytesPerChar = bitsPerChar / 8
        totalBytes = math.ceil(bytesPerChar * len(s))
        return int(s,base).to_bytes(totalBytes, byteorder="big")

    def do_sw(self,args):
        """sw hexAddress (data32bits)+ """
        args = args.split()
        addr = int(args[0],16)
        data = args[1:]
        if len(data) == 0:
            print("invalid amount of data.")
            return
        amount = len(data)
        if amount > (2**6) or amount < 1:
            print("Amount need to fit in 6 bits")
            return
        mes = "11"+"{:06b}".format(amount-1)+"{:032b}".format(addr)
        print("<  {:010x}".format(int(mes,2)))
        mes = self.str2barray(mes,2)
        self.ser.write(mes)
        for d in data:
            d = int(d,16)
            bd = "{:032b}".format(d)
            print("<  {:08x}".format(d))
            barray = self.str2barray(bd,2)
            self.ser.write(barray)

    def replayserialfile(self, fileName):
        r = open(fileName, "rb").read()
        self.ser.write(r)

    def do_replay(self,args):
        """replay fileName"""
        args = args.split()
        self.replayserialfile(args[0])

    def runHexFile():
        pass

    def do_srecl(self, args):
        """srecl srecFileName addresToLadInHex """
        args = args.split()
        fileName = args[0]
        addr = int(args[1],16)
        f = bincopy.BinFile()
        f.add_srec_file(fileName)
        d = f.as_binary()
        datalen = len(d)
        datatimes = datalen//64
        for i in range(0,datatimes+1):
            sendData = d[i*64:64+(i*64)]
            mes = "11"+"{:06b}".format(len(sendData)-1)+"{:032b}".format(addr)
            mes = self.str2barray(mes,2)
            ser.write(mes + sendData)

    def do_sr(self,args):
        """sr hexAddress amount """
        if self.ser == None:
            print("Serial not connected.")
            return
        args = args.split()
        addr = int(args[0],16)
        if addr > 0xffffffff:
            print("Invalid 32bit adress {:x}".format(addr))
            return
        amount = int(args[1])
        if amount > (2**6) or amount < 1:
            print("Amount need to fit in 6 bits")
            return
        mes = "10"+"{:06b}".format(amount-1)+"{:032b}".format(addr)
        print("<  {:010x}".format(int(mes,2)))
        mes = self.str2barray(mes,2)
        self.ser.write(mes)
        for t in range(0,amount):
            res = self.ser.read(4)
            while(len(res) > 0):
                res = int.from_bytes(res, byteorder='big', signed=False)
                print(">  {:08x}".format(res))
                res = self.ser.read(4)

    def do_i(self, args, echo=True):
        """i serialCommandsFileName """
        args = args.split()
        lines = open(args[0], "r").read().split("\n")
        lines = [l.partition("-")[0] for l in lines]
        data = "".join(lines)
        data = data.replace(" ","")
        data = data.replace("\t","")
        data = data.replace("\n","")
        serData = self.str2barray(data, 16);
        if echo:
            print("<  " + data)
        self.ser.write(serData)
        res = self.ser.read(4)
        while(len(res) > 0):
            res = int.from_bytes(res, byteorder='big', signed=False)
            if echo:
                print(">  {:08x}".format(res))
            res = self.ser.read(4)

    def send(self, hexStr):
        self.ser.write(self.str2barray(hexStr,16))

    def recv(self, numBytes):
        res = b""
        res = self.ser.read(4)
        while(len(res) < numBytes):
            res += self.ser.read(4)
        return res

    def do_run(self, args):
        """run adressnHex"""
        args = args.split()
        addr = args[0]
        self.do_i( "partial/runinit1", echo=False)
        #set pc and npc
        mes = "c090400010" + addr
        self.ser.write(self.str2barray(mes, 16))
        mes = "c090400014" + "{:08x}".format(int(addr,16)+4)
        self.ser.write(self.str2barray(mes, 16))
        self.do_i( "partial/runinit2", echo=False)
        #uart loop
        self.processng = True
        while(True):
            #check for trap
            self.send("8090000020")
            self.send("8090000020")
            res = self.recv(4)
            print(res)
            if (res[3] % 2) != 0: # less significant byte is even (0xXXXXXXX1)
                #error!
                self.handle_run_trap()
            self.send("8090000020")    # read dsu break reg
            self.recv(4)
            self.send("8080000104")    # read uart status reg
            self.recv(4)
            self.send("8080000110")   # read uart debug FIFO reg, with the output
            res = self.recv(4)
            print(chr(res[3]))
            if not self.processng:
                break
        print("")
        self.do_i( "partial/runend", echo=False)

    def handle_run_trap(self):
        self.processng = False
        self.send("8090000020") # get trap base register to get trap type
        tt = self.ser.read(4)[3]
        self.send("8090400010") # get pc
        pc = self.ser.read(4)
        pc = int.from_bytes(pc, byteorder='big', signed=False)
        print(
"""Trap occured!
PC = {:08x}
Trap type = {:x}""".format(pc,tt))



    def do_q(self,args):
        print("Quiting...");
        quit()

if __name__ == '__main__':
    if len(sys.argv) != 3:
        print("Usage: rcmon device baudrate")
        quit()
    print("Starting Rcmon...")
    dev = sys.argv[1]
    baud = sys.argv[2]
    prompt = Rcmon(dev, baud)
    prompt.prompt = 'rcmon> '

    def signal_handler(sig, frame):
        if not prompt.processng:
            print("")
            prompt.do_q("")
        else:
            prompt.processng = False
    signal.signal(signal.SIGINT, signal_handler)

    prompt.cmdloop('')
